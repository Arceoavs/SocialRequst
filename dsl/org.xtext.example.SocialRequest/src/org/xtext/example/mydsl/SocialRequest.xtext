grammar org.xtext.example.mydsl.SocialRequest with org.eclipse.xtext.common.Terminals hidden(WS)

generate socialRequest "http://www.xtext.org/example/mydsl/SocialRequest"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Model:
	elements+=AbstractElement+
;

AbstractElement:
	Package | Entity | Repository
;

Package:
	'package' name=PointSeparatedID '{'
		(elements+=AbstractElement)*
	'}'
;

PointSeparatedID:
	ID('.'ID)*
;

Entity:
	'Entity' name=ID (hasUserDetails?='implements' 'UserDetails')? '{'
		attributes+=Attribute+
	'}'
;

Attribute:
	(association=ASSOCIATION)? name=ID ':' typeRef=TypeReference (modifier=Modifier)? ('{'
			(
				('mappedBy:' mappedBy=ID)? &
				('fetch:' fetchType=FETCH_TYPE)? &
				('validations' '{'
					validations+=Validation+
				'}')?
			)
	'}')?
;

TypeReference:
	EntityTypeReference | DataTypeReference
;

EntityTypeReference:
	type=[Entity|FullPackageName]
;

DataTypeReference:
	type=DataType
;

Modifier:
	isLOB?='LOB' | isTransient?='TRANSIENT' | isID?='ID'('('IDGenerationType=GENERATION_TYPE')')?
;

Validation:
	'min:' (min=POSSIBLY_SIGNED_INT) | 'max:' (max=POSSIBLY_SIGNED_INT) |
		'pattern:' regex=STRING | validator=BASIC_VALIDATION | (unique?='unique')
;

terminal BASIC_VALIDATION:
	'NotNull' | 'NotBlank' | 'Past' | 'Email'
;

terminal POSSIBLY_SIGNED_INT returns ecore::EBigDecimal:
	'-'?INT
;

terminal GENERATION_TYPE:
	'AUTO' | 'TABLE' | 'IDENTITY' | 'SEQUENCE'
;

terminal FETCH_TYPE:
	'EAGER' | 'LAZY'
;
	
terminal ASSOCIATION:
	'OneToMany' | 'ManyToOne' | 'OneToOne' | 'ManyToMany'
;

enum DataType:
	STRING='String' | LONG='long' | FLOAT='float' | DOUBLE='double' | CHAR='char' | INT='int' | BOOLEAN='boolean' | DATE='Date'
;

// Repository

Repository:
	'Repository' name=ID 'on' entity=[Entity|FullPackageName] '{'
		queries+=Query+
	'}'
;

Query:
	'query' name=ID(returnsList?=':' 'list' | returnsBoolean?=':' 'boolean')? ('{'
		('params' '{'
			params+=Param*
		'}')?
		
		(sqlQuery=SQLQuery)?
	'}')?
;

Param:
	name=ID':' type=TypeReference
;

SQLQuery:
	select=Select
	from=From
	joins+=Join*
	(where=Where)?
	(order=Order)?
;

Select:
	'SELECT' (isDistinct?='DISTINCT')? '{' clause=ReferenceValue '}'
;

From:
	'FROM' '{' entity=[Entity|FullPackageName] alias=ID '}'
;

Join:
	joinType=JoinType '{' entity=[Entity|FullPackageName] alias=ID '}' ('ON' '{' joinCondition=SQLClause '}')?
;

enum JoinType:
	LEFT_JOIN='LEFT JOIN' | LEFT_OUTER_JOIN='LEFT OUTER JOIN' | CROSS_JOIN='CROSS JOIN' | JOIN='JOIN'
;

SQLString:
	SQLClause | SQLCondition
;

SQLPart:
	SQLClausePart | SQLConditionPart
;

SQLClause:
	parts+=SQLClausePart+
;

SQLClausePart:
	(leftString=STRING)? referenceValue=ReferenceValue (rightString=STRING)?
;

Where:
	'WHERE' '{' condition=SQLCondition '}'
;

SQLCondition:
	parts+=SQLConditionPart+
;

SQLConditionPart:
	(leftString=STRING)? (referenceValue=ReferenceValue | ':'queryParam=[Param]) (rightString=STRING)?
;

ReferenceValue:
	alias=ID('.'attribute=ID)?
;

Order:
	'ORDER' 'BY' '{' clause=SQLClause '}' 
;

FullPackageName hidden():
	ID('.' ID)*
;
