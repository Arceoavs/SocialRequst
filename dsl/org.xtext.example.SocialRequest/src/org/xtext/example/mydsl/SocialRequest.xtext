grammar org.xtext.example.mydsl.SocialRequest with org.eclipse.xtext.common.Terminals hidden(WS)

generate socialRequest "http://www.xtext.org/example/mydsl/SocialRequest"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Model:
	entities+=Entity* repositories+=Repository*
;
	
Entity:
	'Entity' name=ID (hasUserDetails?='implements' 'UserDetails')? '{'
		attributes+=Attribute+
	'}'
;

Attribute:
	(association=Association)? name=ID ':' typeRef=TypeReference (modifier=Modifier)? ('{'
			(
				('mappedBy:' mappedBy=ID)? &
				('fetch:' fetchType=FetchType)? &
				('validations' '{'
					validations+=Validation+
				'}')?
			)
	'}')?
;

TypeReference:
	EntityTypeReference | DataTypeReference
;

EntityTypeReference:
	type=[Entity]
;

DataTypeReference:
	type=DataType
;

Modifier:
	isLOB?='LOB' | isTransient?='TRANSIENT' | isID?='ID'('('IDGenerationType=GenerationType')')?
;

Validation:
	'min:' (min=POSSIBLY_SIGNED_INT) | 'max:' (max=POSSIBLY_SIGNED_INT) |
	  'pattern:' regex=STRING | validator=BasicValidation
;

enum BasicValidation:
	NOT_NULL='NotNull' | NOT_BLANK='NotBlank' | PAST='Past' | UNIQUE='Unique' | EMAIL='Email'
;

terminal POSSIBLY_SIGNED_INT returns ecore::EBigDecimal:
	'-'?INT
;

enum GenerationType:
	AUTO='AUTO' | TABLE='TABLE' | IDENTITY='IDENTITY' | SEQUENCE='SEQUENCE'
;

enum FetchType:
	EAGER='EAGER' | LAZY='LAZY'
;
	
enum Association:
	ONE_TO_MANY='OneToMany' | MANY_TO_ONE='ManyToOne' | ONE_TO_ONE='OneToOne' | MANY_TO_MANY='ManyToMany'
;

enum DataType:
	STRING='String' | LONG='long' | FLOAT='float' | DOUBLE='double' | CHAR='char' | INT='int' | BOOLEAN='boolean' | DATE='Date'
;

// Repository

Repository:
	'Repository' entity=[Entity] '{'
		queries+=Query+
	'}'
;

Query:
	'query' name=ID(isList?=':' 'list')? ('{'
		('params' '{'
			params+=Param*
		'}')?
		
		(sqlQuery=SQLQuery)?
	'}')
;

Param:
	name=ID':' type=TypeReference
;

SQLQuery:
	select=Select
	from=From
	joins+=Join*
	(where=Where)?
	(order=Order)?
;

Select:
	'SELECT' (isDistinct?='DISTINCT')? '{' clause=STRING '}'
;

From:
	'FROM' '{' entity=[Entity] alias=ID '}'
;

Join:
	joinType=JoinType '{' entity=[Entity] alias=ID '}' ('ON' '{' joinCondition=STRING '}')?
;

enum JoinType:
	LEFT_JOIN='LEFT JOIN' | LEFT_OUTER_JOIN='LEFT OUTER JOIN' | CROSS_JOIN='CROSS JOIN' | JOIN='JOIN'
;

Where:
	'WHERE' '{' condition=STRING '}'
;

Order:
	'ORDER BY' '{' order=STRING '}' 
;
