grammar org.xtext.example.mydsl.SocialRequest with org.eclipse.xtext.common.Terminals hidden(WS)

generate socialRequest "http://www.xtext.org/example/mydsl/SocialRequest"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Model:
	elements+=AbstractElement+
;

AbstractElement:
	Package | Entity | Repository
;

Package:
	'package' name=PointSeparatedID '{'
		(elements+=AbstractElement)*
	'}'
;

PointSeparatedID:
	ID('.'ID)*
;

FullPackageName hidden():
	ID('.' ID)*
;

Entity:
	'Entity' name=ID (hasUserDetails?='implements' 'UserDetails')? '{'
		attributes+=Attribute+
	'}'
;

Attribute:
	(association=ASSOCIATION)? name=ID ':' typeRef=TypeReference (modifier=Modifier)? ('{'
			(
				('mappedBy:' mappedBy=ID)? &
				('fetch:' fetchType=FETCH_TYPE)? &
				('validations' '{'
					validations+=Validation+
				'}')?
			)
	'}')?
;

TypeReference:
	EntityTypeReference | DataTypeReference
;

EntityTypeReference:
	type=[Entity|FullPackageName]
;

DataTypeReference:
	type=DataType
;

Modifier:
	isLOB?='LOB' | isTransient?='TRANSIENT' | isID?='ID'('('IDGenerationType=GENERATION_TYPE')')?
;

Validation:
	'min:' (min=POSSIBLY_SIGNED_INT) | 'max:' (max=POSSIBLY_SIGNED_INT) |
		'pattern:' regex=STRING | validator=BASIC_VALIDATION | (unique?='unique')
;

terminal BASIC_VALIDATION:
	'NotNull' | 'NotBlank' | 'Past' | 'Email'
;

terminal POSSIBLY_SIGNED_INT returns ecore::EBigDecimal:
	'-'?INT
;

terminal GENERATION_TYPE:
	'AUTO' | 'TABLE' | 'IDENTITY' | 'SEQUENCE'
;

terminal FETCH_TYPE:
	'EAGER' | 'LAZY'
;
	
terminal ASSOCIATION:
	'OneToMany' | 'ManyToOne' | 'OneToOne' | 'ManyToMany'
;

enum DataType:
	STRING='String' | LONG='long' | FLOAT='float' | DOUBLE='double' | CHAR='char' | INT='int' | BOOLEAN='boolean' | DATE='Date'
;

// Repository

Repository:
	'Repository' name=ID 'on' entity=[Entity|FullPackageName] '{'
		queries+=Query+
	'}'
;

Query:
	'query' name=ID(returnsList?=':' 'list' | returnsBoolean?=':' 'boolean')? ('{'
		('params' '{'
			params+=Param*
		'}')?
		
		(sqlQuery=SQLQuery)?
	'}')?
;

Param:
	name=ID':' type=TypeReference
;

SQLQuery:
	select=Select
	from=From
	joins+=Join*
	(where=Where)?
	(order=Order)?
;

AbstractReferenceValue:
	ReferenceValue | JoinReferenceValue
;

ReferenceValue:
	alias=ID('.'attribute=ID)?
;

Select:
	'SELECT' (isDistinct?='DISTINCT')? clause=ReferenceValue
;

From:
	'FROM' entity=[Entity|FullPackageName] alias=ID
;

Join:
	joinType=JoinType (entity=[Entity|FullPackageName] | '$'reference=JoinReferenceValue) alias=ID ('ON' joinCondition=PrimaryJoinCondition joinConditions+=AdditionalJoinCondition*)?
;

JoinCondition:
	PrimaryJoinCondition | AdditionalJoinCondition
;

JoinReferenceValue:
	alias=ID'.'attribute=ID
;

PrimaryJoinCondition:
	leftReferenceValue=ReferenceValue '=' rightReferenceValue=ReferenceValue
;

AdditionalJoinCondition:
	linkage=ConditionLinkage leftReferenceValue=ReferenceValue '=' rightReferenceValue=ReferenceValue
;

enum JoinType:
	LEFT_JOIN='LEFT JOIN' | LEFT_OUTER_JOIN='LEFT OUTER JOIN' | CROSS_JOIN='CROSS JOIN' | JOIN='JOIN'
;

Where:
	'WHERE' condition=WhereCondition additionalConditions+=AdditionalWhereCondition*
;

SQLCondition:
	WhereCondition | AdditionalWhereCondition
;

WhereCondition:
	parts+=SQLConditionPart+
;

AdditionalWhereCondition:
	linkage=ConditionLinkage parts+=SQLConditionPart+
;

enum ConditionLinkage:
	AND | OR
;

SQLConditionPart:
	leftString=STRING? (referenceValue=ReferenceValue | ':'queryParam=[Param] | '('subquery=SQLQuery')') rightString=STRING?
;

Order:
	'ORDER' 'BY' clause=OrderClause additionalClauses+=AdditionalOrderClause*
;

AbstractOrderClause:
	OrderClause | AdditionalOrderClause
;

OrderClause:
	referenceValue=ReferenceValue order=SQL_SORT_TYPE?
;

AdditionalOrderClause:
	',' referenceValue=ReferenceValue order=SQL_SORT_TYPE?
;

enum SQL_SORT_TYPE:
	ASC | DESC
;
