grammar org.xtext.example.mydsl.SocialRequest with org.eclipse.xtext.common.Terminals hidden(WS)

generate socialRequest "http://www.xtext.org/example/mydsl/SocialRequest"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Model:
	elements+=AbstractElement+
;

AbstractElement:
	Package | Entity | Repository
;

Package:
    'package' name=PointSeperatedID '{'
        (elements+=AbstractElement)*
    '}';
    
PointSeperatedID:
	ID('.'ID)*
;
	
Entity:
	'Entity' name=ID (hasUserDetails?='implements' 'UserDetails')? '{'
		attributes+=Attribute+
	'}'
;

Attribute:
	(association=ASSOCIATION)? name=ID ':' typeRef=TypeReference (modifier=Modifier)? ('{'
			(
				('mappedBy:' mappedBy=ID)? &
				('fetch:' fetchType=FETCHTYPE)? &
				('validations' '{'
					validations+=Validation+
				'}')?
			)
	'}')?
;

TypeReference:
	EntityTypeReference | DataTypeReference
;

EntityTypeReference:
	type=[Entity|FullPackageName]
;

DataTypeReference:
	type=DataType
;

Modifier:
	isLOB?='LOB' | isTransient?='TRANSIENT' | isID?='ID'('('IDGenerationType=GENERATIONTYPE')')?
;

Validation:
	'min:' (min=POSSIBLY_SIGNED_INT) | 'max:' (max=POSSIBLY_SIGNED_INT) |
	  'pattern:' regex=STRING | validator=BASICVALIDATION | (unique?='unique')
;

BASICVALIDATION:
	'NotNull' | 'NotBlank' | 'Past' | 'Email'
;

terminal POSSIBLY_SIGNED_INT returns ecore::EBigDecimal:
	'-'?INT
;

terminal GENERATIONTYPE:
	'AUTO' | 'TABLE' | 'IDENTITY' | 'SEQUENCE'
;

terminal FETCHTYPE:
	'EAGER' | 'LAZY'
;
	
ASSOCIATION:
	'OneToMany' | 'ManyToOne' | 'OneToOne' | 'ManyToMany'
;

enum DataType:
	STRING='String' | LONG='long' | FLOAT='float' | DOUBLE='double' | CHAR='char' | INT='int' | BOOLEAN='boolean' | DATE='Date'
;

// Repository

Repository:
	'Repository' name=ID 'on' entity=[Entity|FullPackageName] '{'
		queries+=Query+
	'}'
;

Query:
	'query' name=ID(returnsList?=':' 'list' | returnsBoolean?=':' 'boolean')? ('{'
		('params' '{'
			params+=Param*
		'}')?
		
		(sqlQuery=SQLQuery)?
	'}')?
;

Param:
	name=ID':' type=TypeReference
;

SQLQuery:
	select=Select
	from=From
	joins+=Join*
	(where=Where)?
	(order=Order)?
;

Select:
	'SELECT' (isDistinct?='DISTINCT')? '{' clause=ReferenceValue '}'
;

From:
	'FROM' '{' entity=[Entity|FullPackageName] alias=ID '}'
;

Join:
	joinType=JoinType '{' entity=[Entity|FullPackageName] alias=ID '}' ('ON' '{' joinConditionLeft=ReferenceValue '=' joinConditionRight=ReferenceValue '}')?
;

enum JoinType:
	LEFT_JOIN='LEFT JOIN' | LEFT_OUTER_JOIN='LEFT OUTER JOIN' | CROSS_JOIN='CROSS JOIN' | JOIN='JOIN'
;

Where:
	'WHERE' '{' condition=SQLcondition '}'
;

SQLcondition:
	parts+=SQLconditionpart+
;

SQLconditionpart:
	leftString?=STRING? value=ReferenceValue rightString?=STRING?;

ReferenceValue:
	(alias=ID('.'attribute=ID)? | {ReferenceValue} ':'methodAttribute=ID?)
;

Order:
	'ORDER' 'BY' '{' clause=SQLcondition '}' 
;

FullPackageName hidden():
	ID('.' ID)*
;
